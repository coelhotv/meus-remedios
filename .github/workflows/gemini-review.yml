name: Gemini Code Review Parser

# Refatorado em 2026-02-19
# - Removido tempo de espera fixo (5 min)
# - Adicionado trigger via webhook (pull_request_review)
# - Implementado parsing de coment√°rios do Gemini
# - Output estruturado para agentes coder

on:
  # Trigger quando Gemini posta review
  pull_request_review:
    types: [submitted]
  
  # Trigger quando PR √© atualizado (novos commits)
  # Necess√°rio para P2.5 - Trigger de Re-review Autom√°tico
  pull_request:
    types: [synchronize]
  
  # Trigger quando Gemini comenta (fallback)
  issue_comment:
    types: [created]
  
  # Manual
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR Number to process'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  GEMINI_BOT_LOGIN: 'gemini-code-assist[bot]'
  NODE_VERSION: '20'

jobs:
  # ==========================================
  # JOB 1: Detectar Review do Gemini
  # ==========================================
  detect:
    name: Detect Gemini Review
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.context.outputs.pr_number }}
      branch: ${{ steps.context.outputs.branch }}
      has_gemini_review: ${{ steps.context.outputs.has_gemini_review }}
      should_run: ${{ steps.context.outputs.should_run }}
    
    steps:
      - name: Extract Context
        id: context
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber;
            let hasGeminiReview = false;
            
            // Determinar PR number baseado no evento
            if (context.eventName === 'workflow_dispatch') {
              prNumber = context.payload.inputs.pr_number;
            } else if (context.eventName === 'pull_request_review') {
              prNumber = context.payload.pull_request.number;
              // Verificar se √© review do Gemini
              hasGeminiReview = context.payload.review.user.login === 'gemini-code-assist[bot]';
            } else if (context.eventName === 'pull_request') {
              // P2.5: Trigger de Re-review Autom√°tico
              prNumber = context.payload.pull_request.number;
              // N√£o √© review do Gemini, √© trigger por novo commit
              hasGeminiReview = false;
            } else if (context.eventName === 'issue_comment') {
              prNumber = context.payload.issue.number;
              // Verificar se √© coment√°rio do Gemini ou comando manual
              const commentUser = context.payload.comment.user.login;
              const commentBody = context.payload.comment.body;
              hasGeminiReview = commentUser === 'gemini-code-assist[bot]' ||
                               commentBody.includes('/gemini review') ||
                               commentBody.includes('@gemini-code-assist');
            }
            
            // Buscar dados do PR
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: parseInt(prNumber)
            });
            
            core.setOutput('pr_number', prNumber);
            core.setOutput('branch', pr.head.ref);
            core.setOutput('has_gemini_review', hasGeminiReview.toString());
            core.setOutput('should_run', 'true');
            
            console.log(`PR #${prNumber}, Branch: ${pr.head.ref}, Gemini Review: ${hasGeminiReview}`);

  # ==========================================
  # JOB 2: Polling para Review (se necess√°rio)
  # ==========================================
  poll-review:
    name: Poll for Gemini Review
    runs-on: ubuntu-latest
    needs: detect
    # S√≥ executa se n√£o detectou review do Gemini ainda
    if: needs.detect.outputs.has_gemini_review != 'true'
    timeout-minutes: 10
    outputs:
      review_found: ${{ steps.poll.outputs.review_found }}
    
    steps:
      - name: Poll for Gemini Review
        id: poll
        uses: actions/github-script@v7
        with:
          script: |
            const maxAttempts = 20; // 20 * 30s = 10 min
            const interval = 30000; // 30 seconds
            const prNumber = parseInt("${{ needs.detect.outputs.pr_number }}");
            
            for (let i = 0; i < maxAttempts; i++) {
              console.log(`Attempt ${i + 1}/${maxAttempts}: Checking for Gemini review...`);
              
              // Buscar reviews do PR
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Buscar coment√°rios do PR
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100
              });
              
              // Verificar se Gemini postou review ou coment√°rio
              const geminiReview = reviews.find(r => 
                r.user.login === 'gemini-code-assist[bot]'
              );
              
              const geminiComment = comments.find(c => 
                c.user.login === 'gemini-code-assist[bot]'
              );
              
              if (geminiReview || geminiComment) {
                console.log('‚úÖ Gemini review found!');
                core.setOutput('review_found', 'true');
                return;
              }
              
              // Aguardar antes da pr√≥xima tentativa
              if (i < maxAttempts - 1) {
                await new Promise(resolve => setTimeout(resolve, interval));
              }
            }
            
            console.log('‚ö†Ô∏è No Gemini review found after polling');
            core.setOutput('review_found', 'false');

  # ==========================================
  # JOB 3: Parsear Coment√°rios
  # ==========================================
  parse:
    name: Parse Gemini Comments
    runs-on: ubuntu-latest
    needs: [detect, poll-review]
    # Executa sempre que detect OU poll-review terminaram (mesmo se skipped)
    # S√≥ roda se detectou review do Gemini OU polling encontrou review
    if: always() && (needs.detect.outputs.has_gemini_review == 'true' || needs.poll-review.outputs.review_found == 'true')
    outputs:
      total_issues: ${{ steps.parse.outputs.total_issues }}
      auto_fixable: ${{ steps.parse.outputs.auto_fixable }}
      needs_agent: ${{ steps.parse.outputs.needs_agent }}
      critical: ${{ steps.parse.outputs.critical }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect.outputs.branch }}
      
      # ==========================================
      # P3.1: Cache de Reviews
      # Restaura cache de reviews anteriores para evitar re-an√°lise
      # ==========================================
      - name: Restore Review Cache
        id: cache-restore
        uses: actions/cache@v4
        with:
          path: .gemini-cache
          key: gemini-review-cache-${{ github.run_id }}
          restore-keys: |
            gemini-review-cache-
      
      # ==========================================
      # FIX: Aguardar coment√°rios inline do Gemini
      # O Gemini posta um resumo inicial rapidamente (~30s),
      # mas os coment√°rios inline v√™m depois (~60-90s).
      # ==========================================
      - name: Wait for Gemini Inline Comments
        id: wait-inline
        uses: actions/github-script@v7
        with:
          script: |
            const maxAttempts = 10; // 10 * 15s = 2.5 min
            const interval = 15000; // 15 seconds
            const prNumber = parseInt("${{ needs.detect.outputs.pr_number }}");
            
            console.log('‚è≥ Waiting for Gemini inline comments...');
            
            for (let i = 0; i < maxAttempts; i++) {
              // Buscar coment√°rios inline (review comments)
              const { data: reviewComments } = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              const geminiInlineComments = reviewComments.filter(c => 
                c.user.login === 'gemini-code-assist[bot]'
              );
              
              if (geminiInlineComments.length > 0) {
                console.log(`‚úÖ Found ${geminiInlineComments.length} Gemini inline comments after ${i * 15} seconds`);
                core.setOutput('inline_comments_found', 'true');
                core.setOutput('inline_comments_count', geminiInlineComments.length.toString());
                return;
              }
              
              console.log(`Attempt ${i + 1}/${maxAttempts}: No inline comments yet, waiting...`);
              
              if (i < maxAttempts - 1) {
                await new Promise(resolve => setTimeout(resolve, interval));
              }
            }
            
            console.log('‚ö†Ô∏è No Gemini inline comments found after 2.5 minutes');
            core.setOutput('inline_comments_found', 'false');
            core.setOutput('inline_comments_count', '0');
      
      - name: Fetch Gemini Comments
        id: fetch
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = parseInt("${{ needs.detect.outputs.pr_number }}");
            
            // Buscar reviews do PR
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // Buscar coment√°rios do PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100
            });
            
            // Buscar coment√°rios inline (review comments)
            const { data: reviewComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // Filtrar apenas coment√°rios do Gemini
            const geminiReviews = reviews.filter(r => 
              r.user.login === 'gemini-code-assist[bot]'
            );
            
            const geminiComments = comments.filter(c => 
              c.user.login === 'gemini-code-assist[bot]'
            );
            
            const geminiReviewComments = reviewComments.filter(c => 
              c.user.login === 'gemini-code-assist[bot]'
            );
            
            // Salvar para parsing
            const data = {
              reviews: geminiReviews,
              comments: geminiComments,
              reviewComments: geminiReviewComments
            };
            
            require('fs').writeFileSync('gemini-raw-comments.json', JSON.stringify(data, null, 2));
            
            console.log(`Found ${geminiReviews.length} reviews, ${geminiComments.length} comments, ${geminiReviewComments.length} review comments`);

      - name: Parse Comments
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Carregar parser
            const parser = require('./.github/scripts/parse-gemini-comments.cjs');
            
            // Carregar dados brutos
            const rawData = JSON.parse(fs.readFileSync('gemini-raw-comments.json', 'utf8'));
            
            // Parsear todos os coment√°rios inline (mais √∫teis)
            const parsedComments = rawData.reviewComments.map(c => parser.parseGeminiComment(c));
            
            // Categorizar issues
            const categorized = parser.categorizeIssues(parsedComments);
            
            // Gerar output estruturado
            const output = parser.generateStructuredOutput(
              parseInt("${{ needs.detect.outputs.pr_number }}"),
              `review-${Date.now()}`,
              parsedComments
            );
            
            // Salvar output
            fs.mkdirSync('.gemini-output', { recursive: true });
            fs.writeFileSync(
              `.gemini-output/review-${{ needs.detect.outputs.pr_number }}.json`,
              JSON.stringify(output, null, 2)
            );
            
            // Outputs para pr√≥ximos jobs
            core.setOutput('total_issues', output.summary.total_issues);
            core.setOutput('auto_fixable', output.summary.auto_fixable);
            core.setOutput('needs_agent', output.summary.needs_agent);
            core.setOutput('critical', output.summary.critical);
            
            console.log('üìä Parsing Results:');
            console.log(`  Total Issues: ${output.summary.total_issues}`);
            console.log(`  Auto-fixable: ${output.summary.auto_fixable}`);
            console.log(`  Needs Agent: ${output.summary.needs_agent}`);
            console.log(`  Critical: ${output.summary.critical}`);

      # ==========================================
      # P3.1: Limpeza de Cache Expirado
      # Remove entradas com mais de 30 dias
      # ==========================================
      - name: Clean Expired Cache
        run: |
          if [ -d ".gemini-cache" ]; then
            echo "üßπ Cleaning expired cache entries..."
            node -e "
              const { cleanExpiredCache, getCacheStats } = require('./.github/scripts/review-cache.js');
              const statsBefore = getCacheStats();
              console.log('Cache stats before cleanup:', statsBefore);
              const removed = cleanExpiredCache(30);
              const statsAfter = getCacheStats();
              console.log('Cache stats after cleanup:', statsAfter);
              console.log(\`Removed \${removed} expired entries\`);
            "
          else
            echo "No cache directory found, skipping cleanup"
          fi
      
      - name: Debug - List files
        run: |
          echo "Current directory: $(pwd)"
          echo "Files in current directory:"
          ls -la
          echo "Files in .gemini-output:"
          ls -la .gemini-output/ || echo "Directory .gemini-output not found"
          echo "Files in .gemini-cache:"
          ls -la .gemini-cache/ || echo "Directory .gemini-cache not found"
          echo "Absolute path:"
          realpath .gemini-output/ || echo "realpath not available"
      
      # ==========================================
      # P3.1: Save Review Cache
      # Salva cache para uso em execu√ß√µes futuras
      # ==========================================
      - name: Save Review Cache
        uses: actions/cache@v4
        with:
          path: .gemini-cache
          key: gemini-review-cache-${{ github.run_id }}
      
      - name: Upload Structured Output
        uses: actions/upload-artifact@v4
        with:
          name: gemini-review-output
          path: .gemini-output/*.json
          retention-days: 7
          if-no-files-found: error
          include-hidden-files: true

  # ==========================================
  # JOB 4: Auto-Fix (se aplic√°vel)
  # ==========================================
  auto-fix:
    name: Apply Auto-Fixes
    runs-on: ubuntu-latest
    needs: [detect, parse]
    # S√≥ executa se parse rodou e encontrou issues auto-fixable
    if: always() && needs.parse.result == 'success' && needs.parse.outputs.auto_fixable > 0
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ needs.detect.outputs.branch }}
          fetch-depth: 0
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install
        run: npm ci
      
      - name: Apply Fixes
        run: |
          npm run lint -- --fix || true
          npx prettier --write "src/**/*.{js,jsx,css}" || true
      
      - name: Check Changes
        id: check
        run: echo "count=$(git diff --name-only | wc -l)" >> $GITHUB_OUTPUT
      
      - name: Commit Auto-Fixes
        if: steps.check.outputs.count > 0
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "fix: auto-fix issues from Gemini Code Review [skip ci]"
          branch: ${{ needs.detect.outputs.branch }}

  # ==========================================
  # JOB 5: Validar
  # ==========================================
  validate:
    name: Validate Build
    runs-on: ubuntu-latest
    needs: [detect, auto-fix]
    # Sempre executa, mesmo se n√£o houve auto-fix
    if: always() && needs.detect.outputs.has_gemini_review == 'true'
    outputs:
      lint: ${{ steps.check.outputs.lint }}
      smoke: ${{ steps.check.outputs.smoke }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect.outputs.branch }}
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install
        run: npm ci
      
      - name: Run Checks
        id: check
        run: |
          if npm run lint; then echo "lint=passed" >> $GITHUB_OUTPUT; else echo "lint=failed" >> $GITHUB_OUTPUT; fi
          if npm run test:smoke; then echo "smoke=passed" >> $GITHUB_OUTPUT; else echo "smoke=failed" >> $GITHUB_OUTPUT; fi


  # ==========================================
  # JOB 6: Aplicar Labels
  # ==========================================
  apply-labels:
    name: Apply Labels
    runs-on: ubuntu-latest
    needs: [detect, parse]
    if: always() && needs.detect.outputs.should_run == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Download Output
        uses: actions/download-artifact@v4
        with:
          name: gemini-review-output
          path: .gemini-output/
        continue-on-error: true
      
      - name: Apply Labels
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Carregar output estruturado
            let reviewData;
            try {
              reviewData = JSON.parse(fs.readFileSync(`.gemini-output/review-${{ needs.detect.outputs.pr_number }}.json`, 'utf8'));
            } catch (e) {
              console.log('Review file not found, using empty data');
              reviewData = { summary: { total_issues: 0, auto_fixable: 0, critical: 0, needs_agent: 0 }, issues: [] };
            }
            
            const { applyLabels } = require('./.github/scripts/apply-labels.cjs');
            const labels = await applyLabels(reviewData, ${{ needs.detect.outputs.pr_number }});
            
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.detect.outputs.pr_number }},
                labels: labels
              });
              console.log(`Applied ${labels.length} labels:`, labels);
            } else {
              console.log('No labels to apply');
            }


  # ==========================================
  # JOB 7: Postar Resumo (Edit√°vel)
  # ==========================================
  # P2.2: Resumo Edit√°vel - Mant√©m apenas um coment√°rio por PR
  # Estrat√©gia: Verifica se existe coment√°rio com marcador GEMINI_REVIEW_SUMMARY
  # - Se existir: atualiza o coment√°rio existente
  # - Se n√£o existir: cria novo coment√°rio
  # ==========================================
  summary:
    name: Post/Update Summary
    runs-on: ubuntu-latest
    needs: [detect, parse, validate]
    # S√≥ executa se parse rodou com sucesso
    if: always() && needs.parse.result == 'success'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Download Output
        uses: actions/download-artifact@v4
        with:
          name: gemini-review-output
          path: .gemini-output/
        continue-on-error: true
      
      - name: Post or Update Summary
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Carregar output estruturado
            let reviewData;
            try {
              reviewData = JSON.parse(fs.readFileSync(`.gemini-output/review-${{ needs.detect.outputs.pr_number }}.json`, 'utf8'));
            } catch (e) {
              console.log('Review file not found, using empty data');
              reviewData = { summary: { total_issues: 0, auto_fixable: 0, critical: 0, needs_agent: 0 }, issues: [] };
            }
            
            const prNumber = parseInt("${{ needs.detect.outputs.pr_number }}");
            
            // Importar e executar script de resumo inteligente
            const { postOrUpdateSummary } = require('./.github/scripts/post-smart-summary.cjs');
            const result = await postOrUpdateSummary(reviewData, prNumber, github, context);
            
            console.log(`Summary ${result.action}: ${result.url}`);

  # ==========================================
  # JOB 8: Trigger Re-review Autom√°tico (P2.5)
  # ==========================================
  # Detecta quando novos commits s√£o pushados e
  # automaticamente solicita re-review do Gemini
  # se as altera√ß√µes forem significativas
  # ==========================================
  trigger-rereview:
    name: Trigger Re-review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'synchronize'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Check and Trigger Re-review
        uses: actions/github-script@v7
        with:
          script: |
            const { shouldTriggerRereview, triggerRereview } = require('./.github/scripts/trigger-re-review.cjs');
            
            const shouldTrigger = await shouldTriggerRereview(
              context.payload.pull_request.number,
              github,
              context
            );
            
            if (shouldTrigger) {
              console.log('Altera√ß√µes significativas detectadas, solicitando re-review...');
              await triggerRereview(
                context.payload.pull_request.number,
                github,
                context
              );
            } else {
              console.log('Altera√ß√µes menores, sem necessidade de re-review');
            }

  # ==========================================
  # JOB 9: Criar Issues para Refactoring (P2.3)
  # ==========================================
  # Cria GitHub Issues automaticamente para issues MEDIUM
  # que n√£o podem ser auto-fixados. Isso move discuss√µes de
  # refactoring para fora da timeline do PR.
  # ==========================================
  create-issues:
    name: Create GitHub Issues
    runs-on: ubuntu-latest
    needs: [detect, parse]
    if: always() && needs.detect.outputs.should_run == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Download Output
        uses: actions/download-artifact@v4
        with:
          name: gemini-review-output
          path: .gemini-output/
        continue-on-error: true
      
      - name: Create Issues
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Carregar output estruturado
            let reviewData;
            try {
              reviewData = JSON.parse(fs.readFileSync(`.gemini-output/review-${{ needs.detect.outputs.pr_number }}.json`, 'utf8'));
            } catch (e) {
              console.log('Review file not found, skipping issue creation');
              return;
            }
            
            // S√≥ criar issues se houver MEDIUM n√£o-auto-fixable
            const mediumIssues = reviewData.issues.filter(i =>
              i.severity === 'MEDIUM' && !i.auto_fixable
            );
            
            if (mediumIssues.length === 0) {
              console.log('Nenhum issue MEDIUM para criar');
              return;
            }
            
            console.log(`Encontrados ${mediumIssues.length} issues MEDIUM n√£o-auto-fix√°veis`);
            
            // Importar e executar script de cria√ß√£o de issues
            const { createIssuesFromReview } = require('./.github/scripts/create-issues.cjs');
            const issues = await createIssuesFromReview(
              reviewData,
              ${{ needs.detect.outputs.pr_number }},
              github,
              context
            );
            
            if (issues.length > 0) {
              console.log(`‚úÖ Criadas ${issues.length} issues: ${issues.map(i => '#' + i).join(', ')}`);
              
              // Adicionar coment√°rio no PR com link para as issues criadas
              const issueLinks = issues.map(num => `- #${num}`).join('\n');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.detect.outputs.pr_number }},
                body: `## ü§ñ Issues de Refactoring Criadas\n\nForam criadas as seguintes issues para acompanhamento de refactoring:\n\n${issueLinks}\n\nEstas issues podem ser implementadas em um PR futuro.`
              });
            } else {
              console.log('Nenhuma issue nova criada (j√° existem issues similares)');
            }
