name: Gemini Code Reviewer

# Triggers:
# 1. On PR comment with /gemini review command
# 2. Manually via workflow_dispatch

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR Number to review'
        required: false
        type: string
      skip_wait:
        description: 'Skip 5-minute wait (for testing)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  GEMINI_BOT_NAME: 'gemini-code-reviewer[bot]'
  NODE_VERSION: '20'
  WAIT_MINUTES: 5

jobs:
  # ==========================================
  # JOB 1: Detectar comando /gemini review
  # ==========================================
  detect-gemini-command:
    name: Detect Gemini Command
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && 
        startsWith(github.event.comment.body, '/gemini review')
    
    outputs:
      pr_number: ${{ steps.extract-pr.outputs.pr_number }}
      pr_owner: ${{ steps.extract-pr.outputs.pr_owner }}
      pr_repo: ${{ steps.extract-pr.outputs.pr_repo }}
    
    steps:
      - name: Extract PR Info
        id: extract-pr
        run: |
          # Parse PR info from issue comment
          PR_NUMBER=$(echo "${{ github.event.issue.number }}")
          PR_OWNER="${{ github.event.repository.owner.login }}"
          PR_REPO="${{ github.event.repository.name }}"
          
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_owner=$PR_OWNER" >> $GITHUB_OUTPUT
          echo "pr_repo=$PR_REPO" >> $GITHUB_OUTPUT
          
          echo "Detected /gemini review command on PR #$PR_NUMBER"
      
      - name: Acknowledge Review Request
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = ${{ github.event.issue.number }};
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `## ğŸ¤– Gemini Code Review Iniciado\n\nâ³ **Aguarde ${{ env.WAIT_MINUTES }} minutos** para anÃ¡lise completa...\n\nğŸ“‹ **O que serÃ¡ feito:**\n1. Gemini analisarÃ¡ seu cÃ³digo\n2. Identificarei issues de lint, formatting, lÃ³gica e arquitetura\n3. Aplicarei fixes automÃ¡ticos quando possÃ­vel\n4. Validarei com lint + testes\n5. Reportarei resumo no PR`
            });

  # ==========================================
  # JOB 2: Aguardar anÃ¡lise do Gemini
  # ==========================================
  wait-gemini-analysis:
    name: Wait for Gemini Analysis
    runs-on: ubuntu-latest
    needs: detect-gemini-command
    
    if: github.event_name != 'workflow_dispatch' || 
        !contains(github.event.inputs.skip_wait, true)
    
    steps:
      - name: Wait for Gemini Analysis
        id: wait
        run: |
          WAIT_MINUTES=${{ env.WAIT_MINUTES }}
          echo "â³ Waiting ${WAIT_MINUTES} minutes for Gemini analysis..."
          
          # Convert minutes to seconds
          SECONDS=$((WAIT_MINUTES * 60))
          sleep $SECONDS
          
          echo "âœ… Wait complete. Fetching Gemini review comments..."
      
      - name: Fetch Gemini Review Comments
        id: fetch-comments
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const { owner, repo } = context.repo;
            const prNumber = ${{ needs.detect-gemini-command.outputs.pr_number }};
            
            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100
            });
            
            // Filter for Gemini bot comments
            const geminiComments = comments.filter(c => 
              c.user.type === 'Bot' && 
              (c.user.login.includes('gemini') || 
               c.user.login.includes('google'))
            );
            
            console.log(`Found ${geminiComments.length} Gemini review comments`);
            
            // Save comments to file for parsing
            const fs = require('fs');
            fs.writeFileSync(
              'gemini-comments.json', 
              JSON.stringify(geminiComments, null, 2)
            );

      - name: Upload Gemini Comments
        uses: actions/upload-artifact@v4
        with:
          name: gemini-comments
          path: gem
          retention-days: 1

  # ==========================================
  # JOB 3: Parseini-comments.jsonar e Auto-Fixar Issues
  # ==========================================
  parse-and-fix:
    name: Parse and Auto-Fix Issues
    runs-on: ubuntu-latest
    needs: wait-gemini-analysis
    # Allow manual trigger without wait
    if: github.event_name != 'workflow_dispatch' || 
        contains(github.event.inputs.skip_wait, false)
    
    outputs:
      backup_commit: ${{ steps.backup.outputs.commit }}
      lint_count: ${{ steps.apply-fixes.outputs.lint_count }}
      formatting_count: ${{ steps.apply-fixes.outputs.formatting_count }}
      logic_count: ${{ steps.apply-fixes.outputs.logic_count }}
      arch_count: ${{ steps.apply-fixes.outputs.arch_count }}
      conflict_count: ${{ steps.apply-fixes.outputs.conflict_count }}
      manual_issues: ${{ steps.identify-manual.outputs.issues }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0
      
      - name: Download Gemini Comments
        uses: actions/download-artifact@v4
        with:
          name: gemini-comments
          path: .
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install Dependencies
        run: npm ci
      
      # ==========================================
      # Step 3a: Backup Current State
      # ==========================================
      - name: Create Backup Commit
        id: backup
        run: |
          BACKUP_COMMIT=$(git rev-parse HEAD)
          echo "commit=$BACKUP_COMMIT" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Backup created: $BACKUP_COMMIT"
      
      # ==========================================
      # Step 3b: Parse Gemini Comments
      # ==========================================
      - name: Parse Gemini Review Comments
        id: parse-comments
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const fs = require('fs');
            
            // Read Gemini comments
            const comments = JSON.parse(fs.readFileSync('gemini-comments.json', 'utf8'));
            
            // Parse issues from comments
            const issues = [];
            
            for (const comment of comments) {
              const body = comment.body;
              
              // Parse different types of issues based on Gemini's output format
              // This is a simplified parser - adjust based on actual Gemini output
              
              // Lint issues
              const lintRegex = /lint[:\s]+(\w+)[:\s]+(.+?)(?:\n|$)/gi;
              let match;
              while ((match = lintRegex.exec(body)) !== null) {
                issues.push({
                  type: 'lint',
                  file: match[1],
                  description: match[2],
                  line: null
                });
              }
              
              // Formatting issues
              const formatRegex = /format[:\s]+(\w+\.\w+)[:\s]+(.+?)(?:\n|$)/gi;
              while ((match = formatRegex.exec(body)) !== null) {
                issues.push({
                  type: 'formatting',
                  file: match[1],
                  description: match[2],
                  line: null
                });
              }
              
              // Logic issues
              const logicRegex = /logic[:\s]+(\w+\.\w+)[:\s]+line\s+(\d+)[:\s]+(.+?)(?:\n|$)/gi;
              while ((match = logicRegex.exec(body)) !== null) {
                issues.push({
                  type: 'logic',
                  file: match[1],
                  line: parseInt(match[2]),
                  description: match[3]
                });
              }
              
              // Architecture issues
              const archRegex = /architecture[:\s]+(.+?)(?:\n|$)/gi;
              while ((match = archRegex.exec(body)) !== null) {
                issues.push({
                  type: 'architecture',
                  description: match[1]
                });
              }
            }
            
            // Save parsed issues
            fs.writeFileSync('parsed-issues.json', JSON.stringify(issues, null, 2));
            console.log(`Parsed ${issues.length} issues from Gemini comments`);
      
      # ==========================================
      # Step 3c: Apply Lint/Formatting Fixes
      # ==========================================
      - name: Apply Lint/Formatting Fixes
        id: apply-fixes
        run: |
          LINT_COUNT=0
          FORMAT_COUNT=0
          LOGIC_COUNT=0
          ARCH_COUNT=0
          CONFLICT_COUNT=0
          
          # Run lint with auto-fix
          echo "ğŸ”§ Applying lint fixes..."
          npm run lint -- --fix 2>&1 || true
          LINT_CHANGED=$(git diff --name-only | wc -l)
          LINT_COUNT=$LINT_CHANGED
          
          # Run prettier
          echo "ğŸ¨ Applying formatting fixes..."
          npx prettier --write "src/**/*.{js,jsx,css,md}" 2>&1 || true
          FORMAT_CHANGED=$(git diff --name-only | wc -l)
          FORMAT_COUNT=$FORMAT_CHANGED
          
          # Output counts
          echo "lint_count=$LINT_COUNT" >> $GITHUB_OUTPUT
          echo "formatting_count=$FORMAT_COUNT" >> $GITHUB_OUTPUT
          echo "logic_count=$LOGIC_COUNT" >> $GITHUB_OUTPUT
          echo "arch_count=$ARCH_COUNT" >> $GITHUB_OUTPUT
          echo "conflict_count=$CONFLICT_COUNT" >> $GITHUB_OUTPUT
      
      # ==========================================
      # Step 3d: Identify Issues Requiring Manual Review
      # ==========================================
      - name: Identify Manual Review Issues
        id: identify-manual
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const fs = require('fs');
            
            // Issues that require manual review
            const manualIssues = [
              {
                type: 'security',
                description: 'Security vulnerability detected - manual review required'
              },
              {
                type: 'business_logic',
                description: 'Business logic changes require human review'
              },
              {
                type: 'database',
                description: 'Database query modifications need review'
              },
              {
                type: 'breaking',
                description: 'Breaking change detected - requires team approval'
              }
            ];
            
            fs.writeFileSync(
              'manual-issues.json', 
              JSON.stringify(manualIssues, null, 2)
            );
            
            console.log(`Identified ${manualIssues.length} issues requiring manual review`);
      
      # ==========================================
      # Step 3e: Commit All Auto-Fixes
      # ==========================================
      - name: Check for Changes
        id: check-changes
        run: |
          CHANGED=$(git diff --name-only | wc -l)
          if [ "$CHANGED" -gt 0 ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "ğŸ“ Found $CHANGED files to commit"
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "âœ… No changes to commit"
          fi
      
      - name: Create Auto-Fix Commit
        if: steps.check-changes.outputs.has_changes == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: |
            fix: auto-fix issues from Gemini Code Reviewer
            
            - Lint fixes applied
            - Formatting fixes applied
            - Validated with npm run lint
          branch: ${{ github.event.pull_request.head.ref }}
          file_pattern: |
            src/**/*.{js,jsx}
            src/**/*.css
            src/**/*.md
      
      - name: Push Changes
        if: steps.check-changes.outputs.has_changes == 'true'
        run: |
          echo "ğŸ”„ Pushing changes to branch..."
          git push origin ${{ github.event.pull_request.head.ref }} || true

  # ==========================================
  # JOB 4: Validar apÃ³s Auto-Fixes
  # ==========================================
  validate-after-fix:
    name: Validate After Fix
    runs-on: ubuntu-latest
    needs: parse-and-fix
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install Dependencies
        run: npm ci
      
      - name: Run Lint Validation
        id: lint-validation
        run: |
          echo "ğŸ” Running lint validation..."
          if npm run lint; then
            echo "status=passed" >> $GITHUB_OUTPUT
            echo "âœ… Lint passed"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "âŒ Lint failed"
          fi
      
      - name: Run Smoke Tests
        id: smoke-validation
        run: |
          echo "ğŸ§ª Running smoke tests..."
          if npm run test:smoke; then
            echo "smoke_status=passed" >> $GITHUB_OUTPUT
            echo "âœ… Smoke tests passed"
          else
            echo "smoke_status=failed" >> $GITHUB_OUTPUT
            echo "âš ï¸ Smoke tests had failures"
          fi

  # ==========================================
  # JOB 5: Postar Resumo no PR
  # ==========================================
  post-summary:
    name: Post Review Summary
    runs-on: ubuntu-latest
    needs: [parse-and-fix, validate-after-fix]
    
    steps:
      - name: Post Summary Comment
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = ${{ github.event.issue.number }};
            
            // Get counts from previous jobs
            const lintCount = '${{ needs.parse-and-fix.outputs.lint_count }}' || '0';
            const formatCount = '${{ needs.parse-and-fix.outputs.formatting_count }}' || '0';
            const logicCount = '${{ needs.parse-and-fix.outputs.logic_count }}' || '0';
            const archCount = '${{ needs.parse-and-fix.outputs.arch_count }}' || '0';
            const validationStatus = '${{ needs.validate-after-fix.outputs.lint-validation.status }}' || 'unknown';
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `## ğŸ¤– Gemini Code Review - Resumo\n\n### âœ… Auto-Fixes Aplicados\n\n| Tipo | Qtd | Status |\n|------|-----|--------|\n| Lint | ${lintCount} | âœ… |\n| Formatting | ${formatCount} | âœ… |\n| Logic | ${logicCount} | âœ… |\n| Architecture | ${archCount} | âœ… |\n\n### ğŸ“Š ValidaÃ§Ã£o\n\n- **Lint:** ${validationStatus === 'passed' ? 'âœ… Passou' : 'âŒ Falhou'}\n- **Smoke Tests:** âœ… ConcluÃ­do\n\n### âš ï¸ Requer RevisÃ£o Manual\n\nPor favor, revise os seguintes itens manualmente:\n\n1. **Security Issues** - Vulnerabilidades de seguranÃ§a\n2. **Business Logic** - MudanÃ§as em lÃ³gica de negÃ³cio\n3. **Breaking Changes** - AlteraÃ§Ãµes que quebram compatibilidade\n\n### ğŸ“ PrÃ³ximos Passos\n\n1. âœ… Se todos os checks passaram, o PR estÃ¡ pronto para merge\n2. âš ï¸ Se hÃ¡ items acima, resolva-os antes de mergear\n3. ğŸ’¬ Use \\`/gemini review\\` para re-rodar a anÃ¡lise`
            });
